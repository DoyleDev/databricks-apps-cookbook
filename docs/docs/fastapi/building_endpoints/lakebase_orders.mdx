---
sidebar_position: 5
---

# Lakebase Orders

This recipe demonstrates how to build a complete orders management API using Lakebase PostgreSQL database. These endpoints provide CRUD operations and various query patterns for handling orders data synchronized from Databricks Unity Catalog.

:::info Prerequisites
- Lakebase resources must be created using the [Create Lakebase Resources](./lakebase_resources_create.mdx) endpoint
- The synced table pipeline must be completed and orders data synchronized from `samples.tpch.orders`
- Database connection must be configured in your application environment
:::

## Overview

The orders API provides six main endpoints for different use cases:

| Endpoint | Method | Purpose | Best For |
|----------|--------|---------|----------|
| `/orders/count` | GET | Get total orders count | Dashboards, monitoring |
| `/orders/sample` | GET | Get 5 sample order keys | Testing, development |
| `/orders/pages` | GET | Page-based pagination | Traditional UIs with page numbers |
| `/orders/stream` | GET | Cursor-based pagination | Large datasets, infinite scroll |
| `/orders/{order_key}` | GET | Get specific order | Order details, lookups |
| `/orders/{order_key}/status` | POST | Update order status | Order processing workflows |

## Code Implementation

```python title="routes/v1/orders.py"
import logging

from config.database import get_async_db
from models.orders import (
    CursorPaginationInfo,
    Order,
    OrderCount,
    OrderListCursorResponse,
    OrderListResponse,
    OrderRead,
    OrderSample,
    OrderStatusUpdate,
    OrderStatusUpdateResponse,
    PaginationInfo,
)
from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from fastapi import APIRouter, Depends, HTTPException, Query

logger = logging.getLogger(__name__)
router = APIRouter(tags=["orders"])

# 1. GET ORDERS COUNT
@router.get("/count", response_model=OrderCount, summary="Get total order count")
async def get_order_count(db: AsyncSession = Depends(get_async_db)):
    try:
        stmt = select(func.count(Order.o_orderkey))
        result = await db.execute(stmt)
        count = result.scalar()
        return OrderCount(total_orders=count)
    except Exception as e:
        logger.error(f"Error getting order count: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve order count")

# 2. GET SAMPLE ORDERS
@router.get("/sample", response_model=OrderSample, summary="Get 5 random order keys")
async def get_sample_orders(db: AsyncSession = Depends(get_async_db)):
    try:
        stmt = select(Order.o_orderkey).limit(5)
        result = await db.execute(stmt)
        order_keys = result.scalars().all()
        return OrderSample(sample_order_keys=order_keys)
    except Exception as e:
        logger.error(f"Error getting sample orders: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve sample orders")

# 3. PAGE-BASED PAGINATION
@router.get("/pages", response_model=OrderListResponse, summary="Get orders with page-based pagination")
async def get_orders_by_page(
    page: int = Query(1, ge=1, description="Page number (1-based)"),
    page_size: int = Query(100, ge=1, le=1000, description="Number of records per page (max 1000)"),
    include_count: bool = Query(True, description="Include total count for pagination info"),
    db: AsyncSession = Depends(get_async_db),
):
    try:
        if include_count:
            count_stmt = select(func.count(Order.o_orderkey))
            count_result = await db.execute(count_stmt)
            total_count = count_result.scalar()
            total_pages = (total_count + page_size - 1) // page_size
        else:
            total_count = -1
            total_pages = -1

        offset = (page - 1) * page_size
        stmt = (
            select(Order)
            .order_by(Order.o_orderkey)
            .offset(offset)
            .limit(page_size + 1)
        )

        result = await db.execute(stmt)
        all_orders = result.scalars().all()

        has_next = len(all_orders) > page_size
        orders = all_orders[:page_size]
        has_previous = page > 1

        pagination_info = PaginationInfo(
            page=page,
            page_size=page_size,
            total_pages=total_pages,
            total_count=total_count,
            has_next=has_next,
            has_previous=has_previous,
        )

        return OrderListResponse(orders=orders, pagination=pagination_info)

    except Exception as e:
        logger.error(f"Error getting page-based orders: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve orders")

# 4. CURSOR-BASED PAGINATION
@router.get("/stream", response_model=OrderListCursorResponse, summary="Get orders with cursor-based pagination")
async def get_orders_by_cursor(
    cursor: int = Query(0, ge=0, description="Start after this order key (0 for beginning)"),
    page_size: int = Query(100, ge=1, le=1000, description="Number of records to fetch (max 1000)"),
    db: AsyncSession = Depends(get_async_db),
):
    try:
        stmt = (
            select(Order)
            .where(Order.o_orderkey > cursor)
            .order_by(Order.o_orderkey)
            .limit(page_size + 1)
        )

        result = await db.execute(stmt)
        all_orders = result.scalars().all()

        has_next = len(all_orders) > page_size
        orders = all_orders[:page_size]
        has_previous = cursor > 0

        next_cursor = orders[-1].o_orderkey if orders and has_next else None
        previous_cursor = max(0, cursor - page_size) if has_previous else None

        pagination_info = CursorPaginationInfo(
            page_size=page_size,
            has_next=has_next,
            has_previous=has_previous,
            next_cursor=next_cursor,
            previous_cursor=previous_cursor,
        )

        return OrderListCursorResponse(orders=orders, pagination=pagination_info)

    except Exception as e:
        logger.error(f"Error getting cursor-based orders: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve orders")

# 5. GET SPECIFIC ORDER
@router.get("/{order_key}", response_model=OrderRead, summary="Get an order by its key")
async def read_order(order_key: int, db: AsyncSession = Depends(get_async_db)):
    try:
        if order_key <= 0:
            raise HTTPException(status_code=400, detail="Invalid order key provided")

        stmt = select(Order).where(Order.o_orderkey == order_key)
        result = await db.execute(stmt)
        order = result.scalars().first()

        if not order:
            raise HTTPException(status_code=404, detail=f"Order with key '{order_key}' not found")

        return order

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error fetching order {order_key}: {e}")
        raise HTTPException(status_code=500, detail="Internal server error occurred")

# 6. UPDATE ORDER STATUS
@router.post("/{order_key}/status", response_model=OrderStatusUpdateResponse, summary="Update order status")
async def update_order_status(
    order_key: int,
    status_data: OrderStatusUpdate,
    db: AsyncSession = Depends(get_async_db),
):
    try:
        if order_key <= 0:
            raise HTTPException(status_code=400, detail="Invalid order key provided")

        check_stmt = select(Order).where(Order.o_orderkey == order_key)
        check_result = await db.execute(check_stmt)
        existing_order = check_result.scalars().first()

        if not existing_order:
            raise HTTPException(status_code=404, detail=f"Order with key '{order_key}' not found")

        existing_order.o_orderstatus = status_data.o_orderstatus
        await db.commit()
        await db.refresh(existing_order)

        return OrderStatusUpdateResponse(
            o_orderkey=order_key,
            o_orderstatus=status_data.o_orderstatus,
            message="Order status updated successfully",
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating status for order {order_key}: {e}")
        raise HTTPException(status_code=500, detail="Failed to update order status")
```

## Endpoint Details

### 1. Get Orders Count (`/orders/count`)

**Purpose**: Get total number of orders in the database

**Response**:
```json
{
  "total_orders": 1500000
}
```

**Usage**:
```bash
curl -X GET "http://localhost:8000/api/v1/orders/count"
```

### 2. Get Sample Orders (`/orders/sample`)

**Purpose**: Get 5 sample order keys for testing and development

**Response**:
```json
{
  "sample_order_keys": [1, 32, 33, 34, 35]
}
```

**Usage**:
```bash
curl -X GET "http://localhost:8000/api/v1/orders/sample"
```

### 3. Page-Based Pagination (`/orders/pages`)

**Purpose**: Traditional pagination with page numbers - ideal for UIs with page controls

**Parameters**:
- `page` (int): Page number (1-based, default: 1)
- `page_size` (int): Records per page (1-1000, default: 100)
- `include_count` (bool): Include total count (default: true)

**Response**:
```json
{
  "orders": [
    {
      "o_orderkey": 1,
      "o_custkey": 370,
      "o_orderstatus": "O",
      "o_totalprice": 172799.49,
      "o_orderdate": "1996-01-02",
      "o_orderpriority": "5-LOW",
      "o_clerk": "Clerk#000000951",
      "o_shippriority": 0,
      "o_comment": "nstructions sleep furiously among"
    }
  ],
  "pagination": {
    "page": 1,
    "page_size": 100,
    "total_pages": 15000,
    "total_count": 1500000,
    "has_next": true,
    "has_previous": false
  }
}
```

**Usage**:
```bash
# First page
curl -X GET "http://localhost:8000/api/v1/orders/pages?page=1&page_size=50"

# Specific page without count (faster)
curl -X GET "http://localhost:8000/api/v1/orders/pages?page=10&include_count=false"
```

### 4. Cursor-Based Pagination (`/orders/stream`)

**Purpose**: High-performance pagination for large datasets - ideal for infinite scroll or data streaming

**Parameters**:
- `cursor` (int): Start after this order key (0 for beginning, default: 0)
- `page_size` (int): Records to fetch (1-1000, default: 100)

**Response**:
```json
{
  "orders": [
    {
      "o_orderkey": 101,
      "o_custkey": 136,
      "o_orderstatus": "O",
      "o_totalprice": 46929.18,
      "o_orderdate": "1996-03-13",
      "o_orderpriority": "5-LOW",
      "o_clerk": "Clerk#000000973",
      "o_shippriority": 0,
      "o_comment": "foxes after the"
    }
  ],
  "pagination": {
    "page_size": 100,
    "has_next": true,
    "has_previous": true,
    "next_cursor": 200,
    "previous_cursor": 0
  }
}
```

**Usage**:
```bash
# First batch
curl -X GET "http://localhost:8000/api/v1/orders/stream?cursor=0&page_size=100"

# Next batch (use next_cursor from previous response)
curl -X GET "http://localhost:8000/api/v1/orders/stream?cursor=100&page_size=100"
```

### 5. Get Specific Order (`/orders/{order_key}`)

**Purpose**: Retrieve complete details for a single order

**Response**:
```json
{
  "o_orderkey": 1,
  "o_custkey": 370,
  "o_orderstatus": "O",
  "o_totalprice": 172799.49,
  "o_orderdate": "1996-01-02",
  "o_orderpriority": "5-LOW",
  "o_clerk": "Clerk#000000951",
  "o_shippriority": 0,
  "o_comment": "nstructions sleep furiously among"
}
```

**Usage**:
```bash
curl -X GET "http://localhost:8000/api/v1/orders/1"
```

### 6. Update Order Status (`/orders/{order_key}/status`)

**Purpose**: Update the status of an existing order

**Request Body**:
```json
{
  "o_orderstatus": "F"
}
```

**Response**:
```json
{
  "o_orderkey": 1,
  "o_orderstatus": "F",
  "message": "Order status updated successfully"
}
```

**Usage**:
```bash
curl -X POST "http://localhost:8000/api/v1/orders/1/status" \
  -H "Content-Type: application/json" \
  -d '{"o_orderstatus": "F"}'
```

## Order Status Values

The TPC-H orders dataset uses these standard status codes:
- `O` - Open
- `F` - Finished  
- `P` - Partial

## Pagination Comparison

### When to Use Page-Based Pagination
✅ **Best for**:
- Small to medium datasets (< 1M records)
- Traditional UI with page numbers
- Users need to jump to specific pages
- Displaying "Page X of Y" information

❌ **Avoid for**:
- Very large datasets (performance degrades)
- Real-time data feeds
- Mobile infinite scroll interfaces

### When to Use Cursor-Based Pagination
✅ **Best for**:
- Large datasets (1M+ records)
- High-performance applications
- Infinite scroll UIs
- Real-time data streaming
- APIs with high concurrency

❌ **Avoid for**:
- UIs requiring page jumps
- Small datasets where page-based is simpler

## Error Handling

### Common HTTP Status Codes

- `200` - Success
- `400` - Invalid parameters (negative order_key, invalid page)
- `404` - Order not found
- `422` - Validation error (invalid request body)
- `500` - Database or server error

### Error Response Format
```json
{
  "detail": "Order with key '999999' not found"
}
```

## Performance Tips

1. **Use cursor pagination** for large datasets (>100K records)
2. **Disable count** in page pagination when not needed (`include_count=false`)
3. **Limit page_size** to reasonable values (100-1000)
4. **Cache count results** for dashboard displays
5. **Index order_key** column for optimal performance (already indexed as primary key)

## Complete Usage Example

Here's a Python example showing how to use all endpoints together:

```python
import requests

class OrdersClient:
    def __init__(self, base_url):
        self.base_url = base_url
    
    def get_count(self):
        """Get total orders count"""
        response = requests.get(f"{self.base_url}/orders/count")
        return response.json()["total_orders"]
    
    def get_samples(self):
        """Get sample order keys for testing"""
        response = requests.get(f"{self.base_url}/orders/sample")
        return response.json()["sample_order_keys"]
    
    def get_page(self, page=1, page_size=100, include_count=True):
        """Get orders using page-based pagination"""
        params = {"page": page, "page_size": page_size, "include_count": include_count}
        response = requests.get(f"{self.base_url}/orders/pages", params=params)
        return response.json()
    
    def stream_orders(self, cursor=0, page_size=100):
        """Get orders using cursor-based pagination"""
        params = {"cursor": cursor, "page_size": page_size}
        response = requests.get(f"{self.base_url}/orders/stream", params=params)
        return response.json()
    
    def get_order(self, order_key):
        """Get specific order by key"""
        response = requests.get(f"{self.base_url}/orders/{order_key}")
        if response.status_code == 404:
            return None
        return response.json()
    
    def update_status(self, order_key, new_status):
        """Update order status"""
        data = {"o_orderstatus": new_status}
        response = requests.post(
            f"{self.base_url}/orders/{order_key}/status", 
            json=data
        )
        return response.json()

# Usage example
client = OrdersClient("http://localhost:8000/api/v1")

# Get overview
total_orders = client.get_count()
print(f"Total orders: {total_orders:,}")

# Test with samples
sample_keys = client.get_samples()
for key in sample_keys:
    order = client.get_order(key)
    print(f"Order {key}: {order['o_orderstatus']} - ${order['o_totalprice']}")

# Browse orders with pagination
page_result = client.get_page(page=1, page_size=10)
print(f"Page 1 has {len(page_result['orders'])} orders")

# Stream orders efficiently
stream_result = client.stream_orders(cursor=0, page_size=100)
print(f"Streamed {len(stream_result['orders'])} orders")
next_cursor = stream_result['pagination']['next_cursor']

# Update an order status
if sample_keys:
    update_result = client.update_status(sample_keys[0], "F")
    print(f"Updated order {sample_keys[0]} status to: {update_result['o_orderstatus']}")
```

## Dependencies

- [Databricks SDK for Python](https://pypi.org/project/databricks-sdk/) - `databricks-sdk`
- [FastAPI](https://pypi.org/project/fastapi/) - `fastapi`
- [SQLAlchemy](https://pypi.org/project/sqlalchemy/) - `sqlalchemy`
- [SQLModel](https://pypi.org/project/sqlmodel/) - `sqlmodel`
- [asyncpg](https://pypi.org/project/asyncpg/) - `asyncpg`
- [uvicorn](https://pypi.org/project/uvicorn/) - `uvicorn`

```python title="requirements.txt"
databricks-sdk
fastapi
sqlalchemy
sqlmodel
asyncpg
uvicorn
```

## Related Documentation

- [Create Lakebase Resources](./lakebase_resources_create.mdx) - Set up the PostgreSQL database
- [Delete Lakebase Resources](./lakebase_resources_delete.mdx) - Clean up resources
- [Read Unity Catalog Tables](./tables_read.mdx) - Query Databricks tables directly